---
sidebarDepth: 3
---

# Read |《你不知道的JS·上》

《你不知道的JavaScript·上卷》

<!-- + + + + + + + + + + + + + + + + + + + + -->

## 01 作用域和闭包 <badge text="2019.7.1" />

### 作用域是什么

- 编程语言的基本功能之一：存储变量当中的值，并能在往后对这个值进行访问及修改；
- 需要一套设计良好的规则来存储变量，并往后可方便寻找到它们 → 这套规则：作用域；

#### 编译原理

- 传统编译的3个步骤：
  1. `分词/词法分析` → 将字符串分解成有意义的代码块（**词法单元**）；
  ```
    分词(tokenizing)和词法分析(Lexing)之间的区别是非常微妙、晦涩的,
  主要差异在于词法单元的识别是通过 有状态 还是 无状态 的方式进行的。简
  单来说,如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法
  单元的一部分时,调用的是有状态的解析规则,那么这个过程就被称为 词法
  分析 。
  ```
  2. `解析/语法分析` → 将词法单元流（数组）转换成一个由元素逐级嵌套组成的树（**抽象语法树**，AST），其代表了程序语法结构；
  3. `代码生成` → 将 AST 转换为可执行代码的过程
- JavaScript 引擎不会有大量的时间来进行优化；
- JavaScript 的编译过程不发生于构建之前；
- 大部分情况，JavaScript 的编译会发生在代码执行前几微秒；
- **任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)；**

### 理解作用域

- `引擎` - 从头到尾负责整个 JavaScript 程序的编译及执行过程；
- `编译器` - 负责语法分析及代码生成；
- `作用域` - 负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限；
- 变量的赋值操作会执行两个动作：
  1. 首先编译器会在当前作用域中声明一个变量（若未声明过);
  2. 然后在运行时引擎会在作用域中查找该变量，若能找到就会对它赋值;

### LHS 和 RHS

- 当变量出现在 **赋值操作** 的左侧时进行 `LHS` 查询，出现在右侧（准确说是“非左侧”）时进行 `RHS` 查询；
- `LHS` 查询试图找到变量的容器本身，从而可对其赋值；
- `RHS` 查询与简单查找某个变量的值别无二致 → Retrieve His Source value，取到其源值；
```
赋值操作其实有多种形式，故准确而言，应进行如下理解：

1- LHS：赋值操作的目标是谁；
2- RHS：谁是赋值操作的源头；
```
- 编译器可以在代码生成的同时处理声明和值的定义；

#### 测验

```js
// 把自己当作引擎，并同作用域进行一次“对话”：
function foo(a) {
var b = a;
return a + b;
}
var c = foo( 2 );

/**
 * 1. 找到其中所有的 LHS 查询。(这里有 3 处!)
 * 2. 找到其中所有的 RHS 查询。(这里有 4 处!)
 * /
 
 ![测验](./imgs/)
```

### 作用域嵌套

- 作用域是根据查找变量的一套规则；
- 实际情况下，通常需要同时去顾及几个作用域；
- **作用域的嵌套** → 当一个块嵌套在另一个块或函数中发生；
- 引擎若在当前作用域中无法找到某个变量时，它就会向外（外层嵌套的作用域）继续查找，直到找到该变量，甚至会抵达最外层作用域（全局作用域）为止；

#### 遍历嵌套作用域链的规则

1. 引擎从当前的执行作用域开始查找变量；
2. 若找不到，就向上一级继续查找；
3. 当抵达最外层全局作用域时，无论找到与否，查找过程都会停止；

### 异常

#### 为啥要区分 LHS 和 RHS？

因为在变量还没有声明，即在任何作用域中都无法找到该变量时，这两种查询的行为时不一样的；

**一个未声明的变量在任何相关的作用域中都无法找到它。**

#### ReferenceError 异常

- 当 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 `ReferenceError异常` → 十分重要的异常类型；
- 当 LHS 查询在顶层（全局作用域）中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返回引擎（前提是程序运行在 “非严格模式” 下）；

##### 严格模式

- ES5 中引入了严格模式；
- 同宽松/懒惰模式相比，严格模式在行为上有很多不同；
- 其一：严格模式禁止自动或隐式地创建全局变量 → 在严格模式下 LHS 查询失败时，并不会创建或返回一个全局变量，引擎会抛出类似的 `ReferenceError异常`；
- RHS 查询找到一个变量，但却对其值进行了不合理的操作（如，试图对一个非函数类型值进行函数调用，或引用 null 或 undefined 类型值中的属性），引擎抛出另一种异常类型 `TypeError`；
- `ReferenceError` 同作用域判别失败相关，而 `TypeError` 则代表作用域判别成功了,但是对结果的操作是非法或不合理的；

### 小结

- 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)；
- 若查找的目的是对变量进行赋值 → LHS 查询；
- 若目的是获取变量的值 → RHS 查询；
- 赋值操作符会导致 LHS 查询；
- `=` 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作；
- JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2` 这样的声明会被分解成两个独立的步骤：
  1. 首先，`var a` 在其作用域中声明新变量 → 最开始的阶段，亦即在代码执行前进行；
  2. 接下来，`a = 2` 会查询（LHS 查询）变量 `a` 并对其进行赋值；
- LHS 和 RHS 查询都会在当前执行作用域中开始，若有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域(一层
楼)，最后抵达全局作用域(顶层)，无论找到或没找到都将停止。
- 不成功的 RHS 引用会导致抛出 ReferenceError 异常；
- 不成功的 LHS 引用会导致自动隐式地创建一个全局变量：
  1. 非严格模式下，该变量使用 LHS 引用的目标作为标识符；
  2. 严格模式下，抛出 ReferenceError 异常；

```
将“作用域”定义为一套规则，
用以管理引擎如何在当前作用域，
以及嵌套的子作用域中根据标识符名称进行变量查找。
```

<!-- + + + + + + + + + + + + + + + + + + + + -->

## 02 词法作用域 <badge text="2019.8.4" />

- 作用域共有2种主要的工作模型：
  1. 词法作用域；
  2. 动态作用域；

### 词法阶段

- 大部分标准语言编译器的第一个工作阶段叫作 **词法化**（也叫 **单词化**）；
- 词法化的过程会对源代码中的字符进行检查，若有状态的解析过，,还会赋予单词语义；
- **词法作用域就是定义在词法阶段的作用域**；
- 词法作用域是由写代码时将变量和块作用域写在哪里来决定的；

#### 查找

- 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置；
- 作用域查找会在找到第一个匹配的标识符时停止；

```
在多层的嵌套作用域中可以定义同名的标识符 - “遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)；
抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，
逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止；
```
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定；

### 欺骗词法

- 词法作用域完全由写代码期间函数所声明的位置来定义，有2种机制可以用来欺骗词法作用域：eval 和 with；
- **欺骗词法作用域会导致性能下降**；
-
#### eval

- eval(..) 通常被用来执行动态创建的代码；
- JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。 setTimeout(..) 和setInterval(..) 的第一个参数可以是字符串,字符串的内容可以被解释为一段动态生成的函数代码 - 不要再用啦；

#### with

- with 通常被当作重复引用同一个对象中的多个属性的快捷方式,可以不需要重复引用对象本身；
- with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符；

```
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化,
因为引擎只能谨慎地认为这样的优化是无效的；
使用这其中任何一个机制都将导致代码运行变慢。

不要使用它们。
```

<!-- + + + + + + + + + + + + + + + + + + + + -->

## 03  <badge text="2019.7.1" />