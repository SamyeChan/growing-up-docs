# 定时器

- JavaScript 中提供的函数，非自定义；
- 作用：每隔一段时间或者延迟一段时间，执行一段指定的代码；
- 分类：
  1. 延迟定时器 `setTimeout`；
  2. 间隔定时器 `setInterval`；
- 页面中可以开启多个定时器；
- 每个定时器都会有一个返回值，这个返回值就是它的 id；

## 延迟定时器

- “延迟一段时间做”；

```js
setTimeout(code, time)
```
- `code` - 延迟一段时间之后，需要做的事 - funtion、字符串(不推荐)；
- `time` - 延迟的时间 - 毫秒(ms) | 默认 0；
- `param1...paramN` - 其余参数 - 定时器完成需要执行的 code 时，作为参数传入；
（IE9及以下不可使用多余参数）
```js
// 传入多于3个的参数
setTimeout(function (x, y) {
  console.log(x);
  console.log(y);
  console.log(x * y);
}, 1000, 2, 3)
```
- 函数会返回其 id；

### 清除延时定时器

```js
clearTimeout(id)
```
- 清除定时器，也是一个函数，需要使用括号 `()` 调用；
- id - 需要清除的定时器的编号；

## 间隔定时器

- “每隔一段时间做”；
- 和 `setTimeout` 实际差不多；

```js
setInterval(code, time)
```
- code - 间隔一段时间之后，需要做的事 - funtion；
- time - 间隔的时间 - 毫秒(ms) | 默认 0；
- param1...paramN - 其余参数 - 定时器完成需要执行的 code 时，作为参数传入；


### 清除间隔定时器

```js
clearInterval(id)
```
- 清除定时器，也是一个函数，需要使用括号 `()` 调用；
- id - 需要清除的定时器的编号；

<!-- 案例：胖子跑步 -->

获取元素的样式：

1. style.xxx - 获取的是行内元素；
2. getComputedStyle(obj)
3. obj.currentStyle()

## 定时器管理

1. 每次开启定时器前，清除上一次定时器；
2. 开关 - 是否决定开启第二次的定时器；

## 定时器存在的问题

### 定时器的 this 指向

1. this - 谁调用，指向谁；
2. 定时器是 js 定义于 window 下的函数，其通过 window 进行调用的；
3. 通过变量存储 this，再调用；

### 参数一引起的性能及 xss 注入问题

- 参数一多为 `function`，也可以是 `字符串`（但不推荐）；
原因：
  1. 影响性能（需要执行2次 - 字符串、函数）；
  2. xxs注入 - 输入恶意代码导致网站运行异常；

### 参数二为0也不会立即执行

```js
// 示例
setTimeout(function () {
  console.log('setTimeout');
}, 0)
console.log('rightnow'); // 会优先输出噢
```
- >= 4ms；
- 若不提供第二个参数，默认为0；

```js
// 一道经典面试题

for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 0)
}
// 5 5 5 5 5
```
- for 循环执行的非常快，但 setTimeout 执行得比 for 循环慢；
- 虽然定时器设置为 0，但并没有立即执行；
- 定时器的最小执行时间 `>=4ms`；

### 参数三可作为第一个function的参数，但IE9以下不支持

如果是有名函数，那么传参需要放到小括号中，而一旦有了小括号，该函数被调用的设置时间就无效了；

1. 法1 - 字符串(不推荐)；
```js
setTimeout('fn(param1, param2)', 1000)

function fu(x,y) {
  console.log(x, y);
}
```
2. 法2 - 用匿名函数包一下
```js
setTimeout(function () {
  fn(param1, param2);
}, 1000)
```
3. 法3 - 修改 this 指向
```js
setTimeout(fn(param1, param2).bind(null, 1, 2), 1000)
```

ps - 上述方法仅解决单个定时器支持问题，不可用于多个情况；